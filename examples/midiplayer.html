<html>
	<head>
		<script src='https://surikov.github.io/webaudiofont/npm/dist/WebAudioFontPlayer.js'></script>
		<script src='MIDIFile.js'></script>
	</head>
	<body>
		<div id='cntls'>
			<p><input type="file" id="filesinput" name="filesarr[]"/></p>
		</div>
		<hr/>
		<p><a href="https://surikov.github.io/webaudiofont/">source</a></p>
		<script>
			console.log('start');
			var audioContext = null;
			var player = null;
			var reverberator = null;
			var songStart = 0;
			var input = null;
			var currentSongTime = 0;
			var nextStepTime = 0;
			function startPlay(song) {
				currentSongTime = 0;
				songStart = audioContext.currentTime;
				nextStepTime = audioContext.currentTime;
				var stepDuration = 44;
				setInterval(function () {
					if (audioContext.currentTime > nextStepTime - stepDuration / 1000) {
						sendNotes(song, songStart, currentSongTime, currentSongTime + stepDuration, audioContext, input, player);
						currentSongTime = currentSongTime + stepDuration;
						nextStepTime = nextStepTime + stepDuration / 1000;
						if (currentSongTime > song.duration) {
							currentSongTime = currentSongTime - song.duration;
						}
					}
				}, 22);
				setInterval(function () {
					showPosition(song, currentSongTime);
				}, 1234);
			}
			function showPosition(song, currentSongTime) {
				var o = document.getElementById('position');
				o.value = 100 * currentSongTime / song.duration;
				document.getElementById('tmr').innerHTML = '' + Math.round(100 * currentSongTime / song.duration) + '%';
			}
			function sendNotes(song, songStart, start, end, audioContext, input, player) {
				for (var i = 0; i < song.notes.length; i++) {
					if (song.notes[i].when >= start && song.notes[i].when < end) {
						var when = songStart + song.notes[i].when / 1000;
						var duration = song.notes[i].duration / 1000;
						var variable = null;
						if (song.notes[i].channel == 9) {
							var drm = song.drums[song.notes[i].pitch].info.variable;
							var v=song.drumvolumes[song.notes[i].pitch]/200;
							console.log('drm',song.notes[i].pitch,v);
							player.queueWaveTable(audioContext, input, window[drm], when, song.notes[i].pitch, duration, v);
						} else {
							var instr = song.channels[song.notes[i].channel].info.variable;
							var v=song.volumes[song.notes[i].channel]/1000;
							console.log('ins',song.notes[i].channel,v);
							player.queueWaveTable(audioContext, input, window[instr], when, song.notes[i].pitch, duration, v);
						}
					}
				}
			}
			function findFirstIns(player, nn) {
				for (var i = 0; i < player.loader.instrumentKeys().length; i++) {
					if (nn == 1 * player.loader.instrumentKeys()[i].substring(0, 3)) {
						return i;
					}
				}
			}
			function findFirstDrum(player, nn) {
				for (var i = 0; i < player.loader.drumKeys().length; i++) {
					if (nn == 1 * player.loader.drumKeys()[i].substring(0, 2)) {
						return i;
					}
				}
			}
			function startLoad(song) {
				console.log(song);
				var AudioContextFunc = window.AudioContext || window.webkitAudioContext;
				audioContext = new AudioContextFunc();
				player = new WebAudioFontPlayer();
				reverberator = player.createReverberator(audioContext);
				reverberator.output.connect(audioContext.destination);
				input = reverberator.input;
				for (var i = 0; i < song.channels.length; i++) {
					var nn = findFirstIns(player, 0 | song.channels[i]);
					var info = player.loader.instrumentInfo(nn);
					song.channels[i] = {
						n: nn,
						info: info
					};
					player.loader.startLoad(audioContext, info.url, info.variable);
				}
				for (var i = 35; i < 82; i++) {
					if (song.drums[i]) {
						var nn = findFirstDrum(player, i);
						var info = player.loader.drumInfo(nn);
						song.drums[i] = {
							n: nn,
							info: info
						};
						player.loader.startLoad(audioContext, info.url, info.variable);
					}
				}
				player.loader.waitLoad(function () {
					console.log('loaded');
					buildControls(song);
				});
			}
			function buildControls(song) {
				console.log('song', song);
				var o = document.getElementById('cntls');
				var html = '<h2>Refresh browser page to load another song</h2><p id="tmr">&nbsp;</p><p><input id="position" type="range" min="0" max="100" value="0" step="1" /></p>';
				html = html + '<h3>Channels</h3>';
				for (var i = 0; i < song.channels.length; i++) {
					var v=100*song.volumes[i]/127;
					html = html + '<p>'+chooserIns(song.channels[i].n)  + '<input id="channel'+i+'" type="range" min="0" max="100" value="'+v+'" step="1" /></p>';
				}
				html = html + '<h3>Drums</h3>';
				for (var i = 35; i < 82; i++) {
					if (song.drums[i]) {
						html = html + '<p>'+chooserDrum(song.drums[i].n)  + '<input id="drum'+i+'" type="range" min="0" max="100" value="100" step="1" /></p>';
					}
				}
				o.innerHTML = html;
				var pos = document.getElementById('position');
				pos.oninput = function (e) {
					player.cancelQueue(audioContext);
					var next = song.duration * pos.value / 100;
					songStart = songStart - (next - currentSongTime) / 1000;
					currentSongTime = next;
				};
				startPlay(song);
			}
			function chooserIns(n) {
				var html = '<select>';
				for (var i = 0; i < player.loader.instrumentKeys().length; i++) {
					var sel = '';
					if (i == n) {
						sel = ' selected';
					}
					html = html + '<option value="' + i + '"' + sel + '>' + i + ': ' + player.loader.instrumentInfo(i).title + '</option>';
				}
				html = html + '</select>';
				return html;
			}
			function chooserDrum(n) {
				var html = '<select>';
				for (var i = 0; i < player.loader.drumKeys().length; i++) {
					var sel = '';
					if (i == n) {
						sel = ' selected';
					}
					html = html + '<option value="' + i + '"' + sel + '>' + i + ': ' + player.loader.drumInfo(i).title + '</option>';
				}
				html = html + '</select>';
				return html;
			}
			function parseMIDIevents(arrayBuffer) {
				var midiFile = new MIDIFile(arrayBuffer);
				console.log(midiFile);
				console.log('getFormat', midiFile.header.getFormat());
				console.log('getTracksCount', midiFile.header.getTracksCount());
				if (midiFile.header.getTimeDivision() === MIDIFile.Header.TICKS_PER_BEAT) {
					console.log('getTicksPerBeat', midiFile.header.getTicksPerBeat());
				} else {
					console.log('getSMPTEFrames', midiFile.header.getSMPTEFrames());
					console.log('getTicksPerFrame', midiFile.header.getTicksPerFrame());
				}
				var events = midiFile.getMidiEvents();
				var song = {
					channels: [],
					drums: [],
					notes: [],
					duration: 0,
					volumes: []
					,drumvolumes: []
				};
				for (var i = 35; i < 82; i++) {
					song.drumvolumes[i]=100;
				}
				for (var i = 0; i < events.length; i++) {
					if (song.duration < events[i].playTime) {
						song.duration = events[i].playTime;
					}
					if (events[i].subtype == MIDIEvents.EVENT_MIDI_NOTE_OFF) {
						for (var cn = 0; cn < song.notes.length; cn++) {
							if (song.notes[cn].channel == events[i].channel //
								 && song.notes[cn].duration == 0.000001 //
								 && song.notes[cn].pitch == events[i].param1 //
								 && song.notes[cn].when < events[i].playTime) {
								song.notes[cn].duration = events[i].playTime - song.notes[cn].when;
								break;
							}
						}
					} else {
						if (events[i].subtype == MIDIEvents.EVENT_MIDI_NOTE_ON) {
							if ((events[i].channel == 9 && events[i].param1 >= 35 && events[i].param1 <= 81)
								 || (events[i].channel != 9 && events[i].param1 >= 0 && events[i].param1 <= 127)) {
								song.notes.push({
									when: events[i].playTime,
									pitch: events[i].param1,
									channel: events[i].channel,
									duration: 0.000001
								});
								if (events[i].channel == 9) {
									song.drums[events[i].param1] = true;
								}
							}
						} else {
							if (events[i].subtype == MIDIEvents.EVENT_MIDI_PROGRAM_CHANGE) {
								//console.log('program', events[i].param1, 'for', events[i].channel, 'at', events[i].playTime);
								song.channels[events[i].channel] = events[i].param1;
							} else {
								if (events[i].subtype == MIDIEvents.EVENT_MIDI_CONTROLLER) {
									if (events[i].param1 == 7) {
										//console.log('volume', events[i].param2, 'for', events[i].channel, 'at', events[i].playTime);
										song.volumes[events[i].channel] = events[i].param2;
									}
								} else {
									if (events[i].subtype == MIDIEvents.EVENT_MIDI_PITCH_BEND) {
										//console.log('bend', events[i].param1, events[i].param2, 'for', events[i].channel, 'at', events[i].playTime);
									} else {
										//
									};
								}
							}
						}
					}
				}
				return song;
			}
			function handleFileSelect(event) {
				console.log(event);
				var file = event.target.files[0];
				console.log(file);
				var fileReader = new FileReader();
				fileReader.onload = function (progressEventÂ ) {
					console.log(progressEvent);
					var arrayBuffer = progressEvent.target.result;
					console.log(arrayBuffer);
					var song = parseMIDIevents(arrayBuffer);
					startLoad(song);
				};
				fileReader.readAsArrayBuffer(file);
			}
			document.getElementById('filesinput').addEventListener('change', handleFileSelect, false);
		</script>
	</body>
</html>
